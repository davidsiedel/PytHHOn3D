from tests import context

from bases.monomial import ScaledMonomial
import numpy as np
import pytest

# ======================================================================================================================
# TESTING THE BASIS POWER MATRIX
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
# DIMENSION 0
# ----------------------------------------------------------------------------------------------------------------------
expected_k1_d0 = np.array([[0]])
expected_k2_d0 = np.array([[0]])
expected_k3_d0 = np.array([[0]])

# ----------------------------------------------------------------------------------------------------------------------
# DIMENSION 1
# ----------------------------------------------------------------------------------------------------------------------
expected_k1_d1 = np.array([[0], [1]])
expected_k2_d1 = np.array([[0], [1], [2]])
expected_k3_d1 = np.array([[0], [1], [2], [3]])

# ----------------------------------------------------------------------------------------------------------------------
# DIMENSION 2
# ----------------------------------------------------------------------------------------------------------------------
expected_k1_d2 = np.array([[0, 0], [0, 1], [1, 0]])
expected_k2_d2 = np.array([[0, 0], [0, 1], [1, 0], [0, 2], [1, 1], [2, 0]])
expected_k3_d2 = np.array([[0, 0], [0, 1], [1, 0], [0, 2], [1, 1], [2, 0], [0, 3], [1, 2], [2, 1], [3, 0]])

# ----------------------------------------------------------------------------------------------------------------------
# DIMENSION 3
# ----------------------------------------------------------------------------------------------------------------------
expected_k1_d3 = np.array([[0, 0, 0], [0, 0, 1], [0, 1, 0], [1, 0, 0]])
expected_k2_d3 = np.array(
    [[0, 0, 0], [0, 0, 1], [0, 1, 0], [1, 0, 0], [0, 0, 2], [0, 1, 1], [0, 2, 0], [1, 0, 1], [1, 1, 0], [2, 0, 0],]
)
expected_k3_d3 = np.array(
    [
        [0, 0, 0],
        [0, 0, 1],
        [0, 1, 0],
        [1, 0, 0],
        [0, 0, 2],
        [0, 1, 1],
        [0, 2, 0],
        [1, 0, 1],
        [1, 1, 0],
        [2, 0, 0],
        [0, 0, 3],
        [0, 1, 2],
        [0, 2, 1],
        [0, 3, 0],
        [1, 0, 2],
        [1, 1, 1],
        [1, 2, 0],
        [2, 0, 1],
        [2, 1, 0],
        [3, 0, 0],
    ]
)

test_data_k_d = [
    (1, 0, expected_k1_d0),
    (2, 0, expected_k2_d0),
    (3, 0, expected_k3_d0),
    (1, 1, expected_k1_d1),
    (2, 1, expected_k2_d1),
    (3, 1, expected_k3_d1),
    (1, 2, expected_k1_d2),
    (2, 2, expected_k2_d2),
    (3, 2, expected_k3_d2),
    (1, 3, expected_k1_d3),
    (2, 3, expected_k2_d3),
    (3, 3, expected_k3_d3),
]


@pytest.mark.parametrize("k,d, expected", test_data_k_d)
def test_basis_exponents(k, d, expected):
    b = ScaledMonomial(k, d)
    assert (b.exponents == expected).all()


# ======================================================================================================================
# TESTING THE BASIS DIMENSION
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
# DIMENSION 0
# ----------------------------------------------------------------------------------------------------------------------
expected_k1_d0 = 1
expected_k2_d0 = 1
expected_k3_d0 = 1
# ----------------------------------------------------------------------------------------------------------------------
# DIMENSION 1
# ----------------------------------------------------------------------------------------------------------------------
expected_k1_d1 = 2
expected_k2_d1 = 3
expected_k3_d1 = 4
# ----------------------------------------------------------------------------------------------------------------------
# DIMENSION 2
# ----------------------------------------------------------------------------------------------------------------------
expected_k1_d2 = 3
expected_k2_d2 = 6
expected_k3_d2 = 10
# ----------------------------------------------------------------------------------------------------------------------
# DIMENSION 3
# ----------------------------------------------------------------------------------------------------------------------
expected_k1_d3 = 4
expected_k2_d3 = 10
expected_k3_d3 = 20

test_data_k_d = [
    (1, 0, expected_k1_d0),
    (2, 0, expected_k2_d0),
    (3, 0, expected_k3_d0),
    (1, 1, expected_k1_d1),
    (2, 1, expected_k2_d1),
    (3, 1, expected_k3_d1),
    (1, 2, expected_k1_d2),
    (2, 2, expected_k2_d2),
    (3, 2, expected_k3_d2),
    (1, 3, expected_k1_d3),
    (2, 3, expected_k2_d3),
    (3, 3, expected_k3_d3),
]


@pytest.mark.parametrize("k,d, expected", test_data_k_d)
def test_basis_dimension(k, d, expected):
    b = ScaledMonomial(k, d)
    assert b.basis_dimension == expected


# ======================================================================================================================
# TESTING POINT COMPUTATION
# ======================================================================================================================

test_data_k_d = []
# ----------------------------------------------------------------------------------------------------------------------
# DIMENSION 0
# ----------------------------------------------------------------------------------------------------------------------
# point = [0.4]
# barycenter = [0.4]
# volume = 1.0
# ----------------------------------------------------------------------------------------------------------------------
expected_k1_d0 = np.array([1.0])
expected_k2_d0 = np.array([1.0])
expected_k3_d0 = np.array([1.0])
test_data_k_d += [
    (1, 0, [0.4], [0.4], 1.0, expected_k1_d0),
    (2, 0, [0.4], [0.4], 1.0, expected_k2_d0),
    (3, 0, [0.4], [0.4], 1.0, expected_k3_d0),
]

# ----------------------------------------------------------------------------------------------------------------------
# DIMENSION 1
# ----------------------------------------------------------------------------------------------------------------------
# point = [0.4]
# barycenter = [1.2]
# volume = 1.5
# ----------------------------------------------------------------------------------------------------------------------
expected_k1_d1 = np.array([1.0, -0.5333333333333333])
expected_k2_d1 = np.array([1.0, -0.5333333333333333, 0.28444444444444444])
expected_k3_d1 = np.array([1.0, -0.5333333333333333, 0.28444444444444444, -0.1517037037037037])
test_data_k_d += [
    (1, 1, [0.4], [1.2], 1.5, expected_k1_d1),
    (2, 1, [0.4], [1.2], 1.5, expected_k2_d1),
    (3, 1, [0.4], [1.2], 1.5, expected_k3_d1),
]

# ----------------------------------------------------------------------------------------------------------------------
# DIMENSION 2
# ----------------------------------------------------------------------------------------------------------------------
# point = [0.4, 1.2]
# barycenter = [0.6, 0.9]
# volume = 1.5
# ----------------------------------------------------------------------------------------------------------------------
expected_k1_d2 = np.array([1.0, 0.19999999999999996, -0.1333333333333333])
expected_k2_d2 = np.array(
    [1.0, 0.19999999999999996, -0.1333333333333333, 0.03999999999999998, -0.026666666666666655, 0.01777777777777777,]
)
expected_k3_d2 = np.array(
    [
        1.0,
        0.19999999999999996,
        -0.1333333333333333,
        0.03999999999999998,
        -0.026666666666666655,
        0.01777777777777777,
        0.007999999999999995,
        -0.00533333333333333,
        0.0035555555555555536,
        -0.0023703703703703686,
    ]
)

test_data_k_d += [
    (1, 2, [0.4, 1.2], [0.6, 0.9], 1.5, expected_k1_d2),
    (2, 2, [0.4, 1.2], [0.6, 0.9], 1.5, expected_k2_d2),
    (3, 2, [0.4, 1.2], [0.6, 0.9], 1.5, expected_k3_d2),
]


@pytest.mark.parametrize("k,d, point, barycenter, volume, expected", test_data_k_d)
def test_basis_phi_vector(k, d, point, barycenter, volume, expected):
    b = ScaledMonomial(k, d)
    phi_vector = b.get_phi_vector(point, barycenter, volume)
    assert (np.abs(phi_vector - expected) < np.full((b.basis_dimension,), 1.0e-9)).all()


# ======================================================================================================================
# TESTING DERIVATIVE POINT COMPUTATION
# ======================================================================================================================

test_data_k_d = []
# ----------------------------------------------------------------------------------------------------------------------
# DIMENSION 1
# ----------------------------------------------------------------------------------------------------------------------
# point = np.array([0.2])
# barycenter = np.array([0.4])
# volume = 1.3
# dx = 0
# ----------------------------------------------------------------------------------------------------------------------

expected_k1_d1 = np.array([-0.0, 0.7692307692307692])
expected_k2_d1 = np.array([-0.0, 0.7692307692307692, -0.23668639053254437])
expected_k3_d1 = np.array([-0.0, 0.7692307692307692, -0.23668639053254437, 0.05461993627674101])

test_data_k_d += [
    (1, 1, np.array([0.2]), np.array([0.4]), 1.3, 0, expected_k1_d1),
    (2, 1, np.array([0.2]), np.array([0.4]), 1.3, 0, expected_k2_d1),
    (3, 1, np.array([0.2]), np.array([0.4]), 1.3, 0, expected_k3_d1),
]

# ----------------------------------------------------------------------------------------------------------------------
# DIMENSION 1
# ----------------------------------------------------------------------------------------------------------------------
# point = np.array([0.2, 1.5])
# barycenter = np.array([0.4, 0.6])
# volume = 1.3
# ----------------------------------------------------------------------------------------------------------------------
expected_k1_d2 = np.array([-0.0, -0.0, 0.7692307692307692])
expected_k2_d2 = np.array([-0.0, -0.0, 0.7692307692307692, -0.0, 0.5325443786982248, -0.23668639053254437])
expected_k3_d2 = np.array(
    [
        -0.0,
        -0.0,
        0.7692307692307692,
        -0.0,
        0.5325443786982248,
        -0.23668639053254437,
        -0.0,
        0.36868456986800174,
        -0.16385980883022302,
        0.05461993627674101,
    ]
)

test_data_k_d += [
    (1, 2, np.array([0.2, 1.5]), np.array([0.4, 0.6]), 1.3, 0, expected_k1_d2),
    (2, 2, np.array([0.2, 1.5]), np.array([0.4, 0.6]), 1.3, 0, expected_k2_d2),
    (3, 2, np.array([0.2, 1.5]), np.array([0.4, 0.6]), 1.3, 0, expected_k3_d2),
]


@pytest.mark.parametrize("k, d, point, barycenter, volume, dx, expected", test_data_k_d)
def test_basis_d_phi_vector(k, d, point, barycenter, volume, dx, expected):
    b = ScaledMonomial(k, d)
    d_phi_vector = b.get_d_phi_vector(point, barycenter, volume, dx)
    assert (np.abs(d_phi_vector - expected) < np.full((b.basis_dimension,), 1.0e-9)).all()
